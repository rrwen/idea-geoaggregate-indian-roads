[
["index.html", "Geoaggregating Roads in India by States and Union Territories (UT) 1 The Idea", " Geoaggregating Roads in India by States and Union Territories (UT) Richard Wen rrwen.dev@gmail.com July 18, 2019 1 The Idea Since I was interested in doing a traffic-related study of India, I wanted to know more about the general characteristics of Indian roads - particularly at the state/UT level. I am also mentoring a student for a brief internship (bright kid with great potential!), and wanted to introduce him to some spatial data handling in R, since he was interested in learning some data analysis. Fortunately, DIVA-GIS provides us with geospatial data of administrative boundaries and roads for free (all in one easily accessible website - pretty awesome!). To implement this idea, I will be providing a brief walkthrough to geospatially aggregating (or geoaggregating) roads by state/Union Territory (UT). The aggregation will involve some spatial intersections, and polyline length/vertex extractions. For the sake of time (as it may be redundant and computationally expensive to process all the states/UTs for this walkthrough), we will play around with one state, but initially look at the entire dataset. "],
["requirements.html", "2 Requirements 2.1 Overview of R Packages 2.2 Loading the R Libraries", " 2 Requirements For this walkthrough we will be using the R programming language. You will need to install: R and RTools programming language and compiler tool R Studio (Suggested) editor for easily working with R sf, mapview, and lwgeom libraries in the R console (seen below) install.packages(c(&quot;sf&quot;, &quot;lwgeom&quot;)) 2.1 Overview of R Packages sf is a very convenient and relatively user-friendly R package that provides tools for working with geometries - making it easy to read, write, and work with geospatial data. mapview provides interactive mapping functionality so we can inspect geospatial data in detail. For our particular purpose, it also provides a handy npts function that allows us to extract the number of vertices given a polygon or polyline. lwgeom is needed by sf to get the lengths of polylines and other geometric objects, so we will install it to satisfy the dependencies. 2.2 Loading the R Libraries After you have finished installing the requirements, don’t forget to load the libraries in the R console!: library(sf) library(mapview) Note: All code will be assumed to be in the R console moving forward. After satisfying all of the requirements, the next section will show you how to get the DIVA-GIS data into R. "],
["getting-the-diva-gis-data.html", "3 Getting the DIVA-GIS Data 3.1 Downloading the Data Automatically 3.2 Inspecting the Data 3.3 Reading the data into R 3.4 Reading the Data for Our Walkthrough", " 3 Getting the DIVA-GIS Data DIVA-GIS provides free country level road and administrative boundary data for all of India, which can be conveniently accessed through the following links: Administrative Boundaries (Download) Roads: (Download) These data are also sourced from GADM, where the data can also be downloaded in additional formats here. 3.1 Downloading the Data Automatically You can download the data manually, but where’s the fun in that? Lets make our code reproducible by making downloads automatic! Notice that the data from the links are zip files, and need to first be unzipped to see its contents. To do that, we will: Download the datasets into a folder called data Unzip the downloaded files Remove the zip files as they are no longer needed # Create a folder called data dir.create(&quot;data&quot;) # Download the admin areas and roads download.file(&quot;http://biogeo.ucdavis.edu/data/diva/adm/IND_adm.zip&quot;, &quot;data/IND_adm.zip&quot;) download.file(&quot;http://biogeo.ucdavis.edu/data/diva/rds/IND_rds.zip&quot;, &quot;data/IND_rds.zip&quot;) # Unzip the downloaded files unzip(&quot;data/IND_adm.zip&quot;, exdir = &quot;data/india-admin-areas&quot;) unzip(&quot;data/IND_rds.zip&quot;, exdir = &quot;data/india-roads&quot;) # Remove the zip files unlink(c(&quot;data/IND_adm.zip&quot;, &quot;data/IND_rds.zip&quot;)) 3.2 Inspecting the Data We can now inspect each of the unzipped folders with the administrative area: list.files(&quot;data/india-admin-areas&quot;) ## [1] &quot;IND_adm0.cpg&quot; &quot;IND_adm0.csv&quot; &quot;IND_adm0.dbf&quot; &quot;IND_adm0.prj&quot; ## [5] &quot;IND_adm0.shp&quot; &quot;IND_adm0.shx&quot; &quot;IND_adm1.cpg&quot; &quot;IND_adm1.csv&quot; ## [9] &quot;IND_adm1.dbf&quot; &quot;IND_adm1.prj&quot; &quot;IND_adm1.shp&quot; &quot;IND_adm1.shx&quot; ## [13] &quot;IND_adm2.cpg&quot; &quot;IND_adm2.csv&quot; &quot;IND_adm2.dbf&quot; &quot;IND_adm2.prj&quot; ## [17] &quot;IND_adm2.shp&quot; &quot;IND_adm2.shx&quot; &quot;IND_adm3.cpg&quot; &quot;IND_adm3.csv&quot; ## [21] &quot;IND_adm3.dbf&quot; &quot;IND_adm3.prj&quot; &quot;IND_adm3.shp&quot; &quot;IND_adm3.shx&quot; ## [25] &quot;license.txt&quot; and the roads data: list.files(&quot;data/india-roads&quot;) ## [1] &quot;IND_roads.dbf&quot; &quot;IND_roads.prj&quot; &quot;IND_roads.shp&quot; &quot;IND_roads.shx&quot; In the administrative area and roads data, there are 4 types of files (.cpg, .dbf, .shp, .prj, .shx), which correspond to character encoding files, database file, shapefile, projection system file, and a shape/font file used commonly by CAD. The main file we will be focusing on here is the shapefile (.shp), which is an ESRI (a well known Geographic Information Systems (GIS) company) vector data format that is widely used in the field of GIS. More details on shapefiles can be found here from ESRI, and here from gdal. 3.3 Reading the data into R Now that we hae some understanding of the file formats, we can try reading some of the files into R: lvl0Data &lt;- st_read(&quot;data/india-admin-areas/IND_adm0.shp&quot;) ## Reading layer `IND_adm0&#39; from data source `D:\\windows\\Users\\rrwen\\Desktop\\idea-geoaggregate-indian-roads\\data\\india-admin-areas\\IND_adm0.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 1 feature and 70 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 68.18625 ymin: 6.754256 xmax: 97.41516 ymax: 35.50133 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs When you read the data into R, it will provide you with some general information about the data: Number of features and fields (rows/geometric objects and columns/variables) Geometry type (point, polygon, linestring, and multi-variants of those) Dimension of the geometric data (2D XY or 3D XYZ) Bounding box (bbox) or the encompassing rectangular area of the data Spatial reference ID (epsg SRID) for defining the projection system used String defining additional parameters for the projection system There are 29 states and 7 UTs in India for a total of 36 states/UTs (knowindia.gov), which means we should have 36 geometric objects in one of the datasets inside data/india-admin-areas. Looks like the file IND_adm0.shp (level 0) only has 1 feature, which is probably not the data level we are looking for. Let’s try the level 1 administrative areas next: lvl1Data &lt;- st_read(&quot;data/india-admin-areas/IND_adm1.shp&quot;) ## Reading layer `IND_adm1&#39; from data source `D:\\windows\\Users\\rrwen\\Desktop\\idea-geoaggregate-indian-roads\\data\\india-admin-areas\\IND_adm1.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 36 features and 9 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 68.18625 ymin: 6.754256 xmax: 97.41516 ymax: 35.50133 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs Hey, this looks like it could be the states/UTS! There are 36 features (geometric objects) here, but just to be sure, lets check the level 2 and 3 data as well: lvl2Data &lt;- st_read(&quot;data/india-admin-areas/IND_adm2.shp&quot;) ## Reading layer `IND_adm2&#39; from data source `D:\\windows\\Users\\rrwen\\Desktop\\idea-geoaggregate-indian-roads\\data\\india-admin-areas\\IND_adm2.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 594 features and 11 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 68.18625 ymin: 6.754256 xmax: 97.41516 ymax: 35.50133 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs lvl3Data &lt;- st_read(&quot;data/india-admin-areas/IND_adm3.shp&quot;) ## Reading layer `IND_adm3&#39; from data source `D:\\windows\\Users\\rrwen\\Desktop\\idea-geoaggregate-indian-roads\\data\\india-admin-areas\\IND_adm3.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 2299 features and 13 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 68.18625 ymin: 6.754256 xmax: 97.41516 ymax: 35.50133 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs The level 2 data has 594 features (a bit too much for states/UTs data), while the level 3 data has even more at 2299 features (far too many objects!). So it looks like the level 1 data is what we are looking for! Let’s map it to further inspect it (more on this in the next section): plot(st_geometry(lvl1Data)) It was not a coincidence that level 1 had 36 features when we look at the map above! To recap, we can see that there are levels 0 to 3 (larger less detailed boundaries at level 0 to smaller more refined boundaries at level 3). Since we are looking for state/UT boundaries (a total of 36), we will use level 1, which has 36 geometric features for our walkthrough. Note: The associated state/UT names can also be extracted from the column NAME_1 which refers to the names for level 1 administrative boundaries: lvl1Data$NAME_1 ## [1] Andaman and Nicobar Andhra Pradesh Arunachal Pradesh ## [4] Assam Bihar Chandigarh ## [7] Chhattisgarh Dadra and Nagar Haveli Daman and Diu ## [10] Delhi Goa Gujarat ## [13] Haryana Himachal Pradesh Jammu and Kashmir ## [16] Jharkhand Karnataka Kerala ## [19] Lakshadweep Madhya Pradesh Maharashtra ## [22] Manipur Meghalaya Mizoram ## [25] Nagaland Orissa Puducherry ## [28] Punjab Rajasthan Sikkim ## [31] Tamil Nadu Telangana Tripura ## [34] Uttar Pradesh Uttaranchal West Bengal ## 36 Levels: Andaman and Nicobar Andhra Pradesh Arunachal Pradesh ... West Bengal 3.4 Reading the Data for Our Walkthrough Based on the inspection above, go ahead and read the appropriate data into a sf object: roads &lt;- st_read(&quot;data/india-roads/IND_roads.shp&quot;) ## Reading layer `IND_roads&#39; from data source `D:\\windows\\Users\\rrwen\\Desktop\\idea-geoaggregate-indian-roads\\data\\india-roads\\IND_roads.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 19148 features and 5 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: 68.49822 ymin: 7.925284 xmax: 97.33479 ymax: 35.50128 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs admin &lt;- st_read(&quot;data/india-admin-areas/IND_adm1.shp&quot;) ## Reading layer `IND_adm1&#39; from data source `D:\\windows\\Users\\rrwen\\Desktop\\idea-geoaggregate-indian-roads\\data\\india-admin-areas\\IND_adm1.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 36 features and 9 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 68.18625 ymin: 6.754256 xmax: 97.41516 ymax: 35.50133 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs The next section will focus on producing some basic maps for visual exploration. "],
["visually-and-interactively-exploring-our-data.html", "4 Visually and Interactively Exploring Our Data 4.1 Static Mapping 4.2 Web Mapping", " 4 Visually and Interactively Exploring Our Data Now that we have set admin to be the loaded administrative area data and roads to be the loaded roads data, we can use sf and mapview to plot their geometry on a static or interactive map. 4.1 Static Mapping Here we need to use st_geometry to generate our static maps on the geometries only, otherwise the sf objects will plot a map for every column of the dataset: plot(st_geometry(admin), axes = T) We chose to show the axis axis = T, giving a general idea of what coordinates each state/UT is located at. We also show the polygonal boundaries to give us a look at how large each state/UT is. Looks like there are relatively larger states/UTs near the northern center of India, while the south and western edges have smaller states/UTs. plot(st_geometry(roads), axes = T) Since road data is generally polylines, and we are using all roads without considering their classification (highways, streets, etc), we can simply plot just the lines. This gives us an idea of which areas in India have more roads (are more road dense) than that of others. We can see that most of the south and eastern areas in India are relatively denser (darker portions) than the other areas. In addition to plotting a single dataset, we can also layer them on top of each other with add = T, change colors with col, and change polygon line (border) colors with border: plot(st_geometry(roads), axes = T, col = &quot;gray&quot;) plot(st_geometry(admin), add = T, border = &quot;red&quot;) In the layered map, we can see that in some states/UTs in the eastern half (near the center) and southern portions of India have areas that are more road dense, while other areas are less road dense when we move towards the west. 4.2 Web Mapping In addition to static mapping, we can also use mapview to interactively explore our data. This will let us zoom, pan around, and click on geometric objects to explore them in detail. It’s pretty cool - try it out!: mapview(admin, viewer.suppress = F) Although we can view single datasets by themselves, they are often not too interesting until we layer them on top of another dataset. We do that by first creating an initial map roadsMap, then we add another map to it with the map = roadsMap option, which tells mapView which existing map the new map should be added to: Finally, let’s play around with some styling options and create a dark themed map! # Create an interactive roads map roadsMap &lt;- mapview(roads, viewer.suppress = F, legend = F, map.types = &quot;CartoDB.DarkMatter&quot;, color = &quot;#d2d2d2&quot;, alpha = 0.5, # transparency layer.name = &quot;Roads&quot;, lwd = 0.75) # line width # Add state/UT map to roads map mapView(admin, map = roadsMap, color = &quot;#f5f5f5&quot;, col.region = &quot;#f5f5f5&quot;, alpha = 0.75, alpha.regions = 0, # remove polygon fill to see roads underneath layer.name = &quot;States/UTs&quot;, lwd = 1) As we saw before, particular regions have more “compact” roads or road density - notably the eastern half of India and towards the south. We can inspect some of the states in these areas further by clicking on them. Here a few states are worth noting as they are more “road dense” throughout their entire areas: Jharkhand, Tamil Nadu, Telangana, Karnataka, Chhattisgarh (to name a few). However, visual inspection can be a little subjective as it can be based on perspective and visual design - this is where doing some calculations with the data will help! In the next section, we will use sf, lwgeom, and mapview to extract road lengths and vertices, and to geoaggregate them into a chosen state/UT to demonstrate some spatial processing. "],
["extracting-road-lengths-and-vertices.html", "5 Extracting Road Lengths and Vertices 5.1 Picking the State for Our Approach 5.2 Extracting Intersecting Roads 5.3 Calculating Road Lengths and Vertex Statistics 5.4 Adding Statistics to the State/UT 5.5 Reviewing the Processing Times for Extraction", " 5 Extracting Road Lengths and Vertices Ideally, we would want to apply the following approach for each state/UT to get the aggregate road lengths and vertices for all of India: Get the roads that spatially intersect (approximately) the state/UT Calculate the min/max/mean/sum lengths and vertices of intersecting roads Add these calculated values to the admin data The goal is to have road length and vertex statistics for each state/UT in India for a more numeric comparison between states/UTs, and possibly some more accurate maps. However, we will process only an average sized state in the dataset as the rest of the states/UTs will simply be repetitions of the approach above. Note 1: The spatial intersection (first step of our approach) here may not be completely accurate as we are only checking for roads that intersect each state/UT, but we are not trimming/cutting long roads that lie inside a state/UT and extend partially outside of it. Note 2: For simplicity, We have not projected the geographic coordinates (spherical coordinates measured from earth’s center) into planar coordinates (projected geographic coordinates onto a 2D surface) so the intersection algorithm may also not be completely accurate when measuring distances to determine if roads intersect the state/UTs. 5.1 Picking the State for Our Approach We will look at the different areas of the states/UTs in meters squared, and pick a state closest to the average area as our selection criteria. The idea is to select a state with an average area so we have an idea how long it will roughly take to process one state of average size. First, we can compute the areas in meters squared and add it to our administrative areas data admin, then plot it as a bar graph: # Get areas in meters squared and add it to the data admin$area_meters_sq &lt;- st_area(admin) # Sort the data by area admin &lt;- admin[order(-admin$area_meters_sq), ] # Produce a bar plot of the state/UT names and their areas x &lt;- as.numeric(admin$area_meters_sq) y &lt;- admin$NAME_1 par(mar=c(4.5, 6, 0, 1)) # Increase margins to fit plot barplot(x, names.arg = y, horiz = T, las = 2, cex.names = 0.5, # hor. labels border = &quot;white&quot;) # line color of bars We can see from the graph that India has relatively even number of state/UTs of varying sizes from 34854465.8555182 to 341901545477.538. Next, we want to get the state closest to the average size given all states/UTs in India. For reference, this will be the state/UT with an area that has the smallest absolute difference from the average state/UT area: The mean can be calculated as: \\[ \\bar{x} = \\frac{x_1 + x_2 + x_3 \\dots x_n}{n} \\] where \\(\\bar{x}\\) is the average area of all state/UTs, \\(x_1 + x_2 + x_3 \\dots x_n\\) is the sum of the areas for a states 1 to 36, and \\(n\\) is the number of states (36 in this case). x &lt;- admin$area_meters_sq xMean &lt;- mean(x) The absolute differences from the average area for each state/UT are then represented as a set \\(\\{d_1, d_2, d_3 \\dots d_n\\}\\) given by subtracting the state/UT areas \\(\\{x_1, x_2, x_3, \\dots x_n\\}\\) from the average area of all state/UTs \\(\\bar{x}\\): \\[ \\{d_1, d_2, d_3 \\dots d_n\\} = | \\{x_1, x_2, x_3, \\dots x_n\\} - \\bar{x}| \\] d &lt;- abs(x - xMean) We then want the state/UT with the smallest difference from the set (the state/UT with an area closest to the average size of all states/UTs in India), stored in the variable stateUT: \\[ min(\\{d_1, d_2, d_3 \\dots d_n\\}) \\] dMin &lt;- min(d) stateUT &lt;- admin[which(d == dMin),] Let’s inspect the state/UT we picked from our selection criteria: stateUT[, c(&quot;NAME_1&quot;, &quot;area_meters_sq&quot;)] ## Simple feature collection with 1 feature and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 85.82636 ymin: 21.53945 xmax: 89.87755 ymax: 27.22103 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## NAME_1 area_meters_sq geometry ## 36 West Bengal 85229170237 [m^2] MULTIPOLYGON (((88.01861 21... We can see that we selected state/UT West Bengal, with an area of 85229170236.714 meters squared, which is close to the average area of 87564698596.7968 meters squared. 5.2 Extracting Intersecting Roads Now that we have chosen our state/UT, lets start the extraction by trying to get all the roads that intersect a single state/UT (since this is the start of the process, we also want to keep track of the processing time with Sys.time): # Track the start time of our extraction process for a single state/UT startTime1 &lt;- Sys.time() # Get intersecting roads for state/UT inStateUT &lt;- st_intersects(roads, stateUT, sparse = F) stateUTRoads &lt;- roads[inStateUT, ] # Time for intersection processing intersectTime &lt;- Sys.time() - startTime1 # Plot the intersecting roads with the state/UT to check plot(st_geometry(stateUT), axes = T, border = &quot;red&quot;) plot(st_geometry(stateUTRoads), add = T) Looking at the plot, we can see that we have extracted the roads that touch or intersect the second state West Bengal, but it does not actually trim or cut the roads when they extend past the state/UT borders. We can use st_intersection (will trim and only keep geometries that are inside the state/UT) for more accuracy, but the computation time would rise, so we will stick with st_intersects (only checks for TRUE or FALSE comparisons, but does not modify the geometries) for the purpose of this walkthrough. 5.3 Calculating Road Lengths and Vertex Statistics Lets move on and extract the min/max/mean/sum road lengths and vertices for West Bengal: # Track the time it takes for calculating road lengths and vertices startTime2 &lt;- Sys.time() # Extract the length stats stateUTRoadsLength &lt;- st_length(stateUTRoads) stateUTLengthStats &lt;- c(min(stateUTRoadsLength, na.rm = T), max(stateUTRoadsLength, na.rm = T), mean(stateUTRoadsLength, na.rm = T), sum(stateUTRoadsLength, na.rm = T)) stateUTLengthStats &lt;- as.numeric(stateUTLengthStats) # Extract the vertices stats stateUTRoadsVertex &lt;- npts(stateUTRoads, by_feature = T) stateUTVertexStats &lt;- c(min(stateUTRoadsVertex, na.rm = T), max(stateUTRoadsVertex, na.rm = T), mean(stateUTRoadsVertex, na.rm = T), sum(stateUTRoadsVertex, na.rm = T)) stateUTVertexStats &lt;- as.numeric(stateUTVertexStats) # Time for calculating lengths and vertices calcTime &lt;- Sys.time() - startTime2 # Combine the stats and name them stateUTStats &lt;- c(stateUTLengthStats, stateUTVertexStats) names(stateUTStats) &lt;- c(&quot;min_length_meters&quot;, &quot;max_length_meters&quot;, &quot;mean_length_meters&quot;, &quot;sum_length_meters&quot;, &quot;min_vertices_meters&quot;, &quot;max_vertices_meters&quot;, &quot;mean_vertices_meters&quot;, &quot;sum_vertices_meters&quot;) print(stateUTStats) ## min_length_meters max_length_meters mean_length_meters ## 2.127547e-01 7.317646e+04 1.177045e+04 ## sum_length_meters min_vertices_meters max_vertices_meters ## 1.053455e+07 2.000000e+00 5.700000e+01 ## mean_vertices_meters sum_vertices_meters ## 9.212291e+00 8.245000e+03 5.4 Adding Statistics to the State/UT Finally, we can add the calculated road lengths and vertex statistics to the state/UT West Bengal by converting it into a dataframe, adding the statistics, and then converting it back into a sf object: # Add the stats to the single state/UT stateUT &lt;- data.frame(stateUT) stateUT[, names(stateUTStats)] &lt;- stateUTStats stateUT &lt;- st_sf(stateUT) # Interactively view the results mapview(stateUT, viewer.suppress = F) Click on the state, and you will now notice that there are extra data on the road length and vertex statistics added to it. If we had done this for all the other states/UTs, we can compare them using numbers, and highlight states/UTs with road densities that are higher than normal to give a better visual representation of our data, but for now we have shown that we can indeed process one state/UT in a reasonable amount of time, and can repeat this process for all the other 35 states/UTs. 5.5 Reviewing the Processing Times for Extraction Now that we have extracted the road lengths and vertices for the state, we can check how long it took us approximately to process the steps. Remember that we tracked the intersection processing time intersectTime and road length/vertices calculation time calcTime. Lets have a look at these: # Calculate the total processing time totalTime &lt;- intersectTime + calcTime # Display the processing times cat(&quot;Spatial Intersection:&quot;, format(intersectTime, usetz = T), &quot;\\nRoad Length/Vertices Calculation Time:&quot;, format(calcTime, usetz = T), &quot;\\nTotal Time:&quot;, format(totalTime, usetz = T)) ## Spatial Intersection: 11.488 secs ## Road Length/Vertices Calculation Time: 0.04597616 secs ## Total Time: 11.53398 secs We can see that the total time for our extraction approach is 11.53398 secs, which could roughly be more or less 11.53398 secs multiplied by 36 (the number of state/UTs) for an estimate of 415.2232 secs. This could scale to much larger processing times if we were to use more detailed data, or if we were to use smaller levels of administrative boundaries/geometries of interest. However, processing one state/UT will give us a good idea of how long it will take to process all states/UTs. Note: We did not consider the min/max/mean/sum calculations that may factor into the time and the addition of the calculated statistics into the admin dataset, but they generally should not take too much processing time. "],
["ending-off-with-a-few-thoughts.html", "6 Ending Off with a Few Thoughts", " 6 Ending Off with a Few Thoughts We started with the idea to extract a number of informative aggregate characteristics of roads in India by state/UT, but found that there may be some issues with accuracy (coordinate system and trimming near state/UT boundaries) and computation time (time it took to process one state/UT). Ideally, we should project each state/UT to an appropriate planar coordinate system to achieve more accurate spatial intersection results. There should probably also be a good amount of trimming/cutting involved as roads tend to be partially outside the boundaries of the states/UTs. Although the data was only a few megabytes, the computation time was roughly 11.53 secs minutes for the single state/UT, estimated to be 415.22 secs for all state/UTs. This could be problematic as we receive finer boundary or road data, and scale to larger more detailed datasets. Some exploration into optimizing the spatial intersections and trimming/cutting could be a good start to obtaining quicker results in a reasonable amount of time (especially for learning or education). Getting the road lengths and vertices statistics could be useful (as far as I can tell) in providing information on road complexity and development. This could be a potentially good measure for getting a glimpse at the general road design at a state/UT level, while providing some insight into whether or not road design at that level has an effect on important applications such as road traffic safety. Overall, R has proven to be great for trying out ideas, experimenting with new libraries, and providing an easier transition into open source data analysis for those unfamiliar with spatial data handling - particularly when install.packages just works without any hiccups on windows! I am hoping to take this idea a little further and apply it to study traffic crashes in India, and perhaps refine this walkthrough so it becomes a little more beginner friendly. It was a lot of fun to write this and I’m hoping to try out some more ideas/thoughts when I have time! "]
]
