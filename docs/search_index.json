[
["index.html", "Geoaggregating Roads in India by States and Union Territories (UT) 1 The Idea", " Geoaggregating Roads in India by States and Union Territories (UT) Richard Wen 17/07/2019 1 The Idea Since I was interested in doing a traffic-related study of India, I wanted to know more about the general characteristics of Indian roads - particularly at the state/UT level. I am also mentoring a student for a brief internship, and wanted to introduce him to some spatial data handling in R since he was interested in learning some data analysis. Fortunately, DIVA-GIS provides us with geospatial data of administrative boundaries and roads for free (all in one easily accessible website - pretty awesome!). To implement this idea, I will be providing a brief walkthrough to geospatially aggregating (or geoaggregating) roads by state/UT. The aggregation will involve some spatial intersections, and polyline length/vertex extractions. For the sake of time (as it is computationally expensive to process all the states/UTs), we will do one state, but initially look at the entire dataset. "],
["requirements.html", "2 Requirements 2.1 Overview of R Packages 2.2 Loading the R Libraries", " 2 Requirements For this walkthrough, you will need to install: R and RTools programming language and compiler tool R Studio (Suggested) editor for easily working with R sf, mapview, and lwgeom libraries in the R console (seen below) install.packages(c(&quot;sf&quot;, &quot;lwgeom&quot;)) 2.1 Overview of R Packages sf is a very convenient and relatively user-friendly R package that provides tools for working with geometries - making it easy to read, write, and work with geospatial data. mapview provides interactive mapping functionality so we can inspect geospatial data in detail. For our particular purpose, it also provides a npts function that allows us to extract the number of vertices given a polygon or polyline. lwgeom is needed by sf to get the lengths of polylines. 2.2 Loading the R Libraries After you have finished installing the requirements, don’t forget to load the libraries in the R console! library(sf) library(mapview) Note: All code will be assumed to be in the R console moving forward. After satisfying all the requirements, the next section will show you how to get the DIVA-GIS data into R. "],
["getting-the-diva-gis-data.html", "3 Getting the DIVA-GIS Data 3.1 Downloading the Data 3.2 Inspecting the Data 3.3 Reading the data into R", " 3 Getting the DIVA-GIS Data DIVA-GIS provides free country level road and administrative boundary data for all of India, which can be accessed through the following links: Administrative Boundaries (Download) Roads: (Download) 3.1 Downloading the Data Notice that these are zip files and need to first be unzipped to see its contents. To do that, we will: Download the datasets into a folder called data Unzip the downloaded files Remove the zip files as they are no longer needed # Create a folder called data dir.create(&quot;data&quot;) # Download the admin areas and roads download.file(&quot;http://biogeo.ucdavis.edu/data/diva/adm/IND_adm.zip&quot;, &quot;data/IND_adm.zip&quot;) download.file(&quot;http://biogeo.ucdavis.edu/data/diva/rds/IND_rds.zip&quot;, &quot;data/IND_rds.zip&quot;) # Unzip the downloaded files unzip(&quot;data/IND_adm.zip&quot;, exdir = &quot;data/india-admin-areas&quot;) unzip(&quot;data/IND_rds.zip&quot;, exdir = &quot;data/india-roads&quot;) # Remove the zip files unlink(c(&quot;data/IND_adm.zip&quot;, &quot;data/IND_rds.zip&quot;)) 3.2 Inspecting the Data We can now inspect each of the unzipped folders with the administrative area: list.files(&quot;data/india-admin-areas&quot;) ## [1] &quot;IND_adm0.cpg&quot; &quot;IND_adm0.csv&quot; &quot;IND_adm0.dbf&quot; &quot;IND_adm0.prj&quot; ## [5] &quot;IND_adm0.shp&quot; &quot;IND_adm0.shx&quot; &quot;IND_adm1.cpg&quot; &quot;IND_adm1.csv&quot; ## [9] &quot;IND_adm1.dbf&quot; &quot;IND_adm1.prj&quot; &quot;IND_adm1.shp&quot; &quot;IND_adm1.shx&quot; ## [13] &quot;IND_adm2.cpg&quot; &quot;IND_adm2.csv&quot; &quot;IND_adm2.dbf&quot; &quot;IND_adm2.prj&quot; ## [17] &quot;IND_adm2.shp&quot; &quot;IND_adm2.shx&quot; &quot;IND_adm3.cpg&quot; &quot;IND_adm3.csv&quot; ## [21] &quot;IND_adm3.dbf&quot; &quot;IND_adm3.prj&quot; &quot;IND_adm3.shp&quot; &quot;IND_adm3.shx&quot; ## [25] &quot;license.txt&quot; and the roads data: list.files(&quot;data/india-roads&quot;) ## [1] &quot;IND_roads.dbf&quot; &quot;IND_roads.prj&quot; &quot;IND_roads.shp&quot; &quot;IND_roads.shx&quot; In the administrative area and roads data, there are 4 types of files (.cpg, .dbf, .shp, .prj, .shx), which correspond to character encoding files, database file, shapefile, projection system file, and a shape/font file used commonly by CAD. The main file we will be focusing on here is the shapefile (.shp). For the administrative area data, there are also levels 0 to 3 (larger less detailed boundaries to smaller more refined boundaries). Since we are looking for state/UT boundaries (a total of 36), we will use level 1, which has 36 geometric features. 3.3 Reading the data into R Based on the inspection above, go ahead and read the appropriate data into a sf object: roads &lt;- st_read(&quot;data/india-roads/IND_roads.shp&quot;) ## Reading layer `IND_roads&#39; from data source `D:\\windows\\Users\\rrwen\\Desktop\\idea-geoaggregate-indian-roads\\data\\india-roads\\IND_roads.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 19148 features and 5 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: 68.49822 ymin: 7.925284 xmax: 97.33479 ymax: 35.50128 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs admin &lt;- st_read(&quot;data/india-admin-areas/IND_adm1.shp&quot;) ## Reading layer `IND_adm1&#39; from data source `D:\\windows\\Users\\rrwen\\Desktop\\idea-geoaggregate-indian-roads\\data\\india-admin-areas\\IND_adm1.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 36 features and 9 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 68.18625 ymin: 6.754256 xmax: 97.41516 ymax: 35.50133 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs When you read the data into R, it will provide you with some general information about the data: Number of features and fields (rows/geometric objects and columns/variables) Geometry type (point, polygon, linestring, and multi-variants of those) Dimension of the geometric data (2D XY or 3D XYZ) Bounding box (bbox) or the encompassing rectangular area of the data Spatial reference ID (epsg SRID) for defining the projection system used String defining additional parameters for the projection system The next section will focus on producing some quick and basic maps for visual exploration. "],
["visually-and-interactively-exploring-our-data.html", "4 Visually and Interactively Exploring Our Data 4.1 Static Mapping 4.2 Web Mapping", " 4 Visually and Interactively Exploring Our Data Now that we have set admin to be the loaded administrative area data and roads to be the loaded roads data, we can use sf and mapview to plot their geometry on a static or interactive map. 4.1 Static Mapping Here we need to use st_geometry to generate our static maps on the geometries only, otherwise the sf objects will plot a map for every column of the dataset: plot(st_geometry(admin), axes = T) We chose to show the axis axis = T, giving a general idea of what coordinates each state/UT is located at. We also show the polygonal boundaries to give us a look at how large each state/UT is. plot(st_geometry(roads), axes = T) Since road data is generally polylines, and we are using all roads without considering their classification (highways, streets, etc), we can simply plot just the lines. This gives us an idea of which areas in India have more roads (are more road dense) than that of others. We can see that most of the south and eastern areas in India are relatively denser (darker portions) than the other areas. 4.2 Web Mapping In addition to static mapping, we can also use mapview to interactively explore our data. This will let us zoom, pan around, and click on geometric objects to explore them in detail. It’s pretty cool - try it out!: mapview(admin, viewer.suppress = F) mapview(roads, viewer.suppress = F) Next, we will use sf, lwgeom, and mapview to extract road lengths and vertices, and to geoaggregate them into our states/UTs. "],
["extracting-road-lengths-and-vertices.html", "5 Extracting Road Lengths and Vertices 5.1 Picking the State for Our Approach 5.2 Extracting Intersecting Roads 5.3 Calculating Road Lengths and Vertex Statistics 5.4 Adding Statistics to the State/UT 5.5 Reviewing the Processing Times for Extraction", " 5 Extracting Road Lengths and Vertices Ideally, we will apply the following approach for each state/UT to get the aggregate road lengths and vertices for all of India: Get the roads that spatially intersect (approximately) the state/UT Calculate the min/max/mean/sum lengths and vertices of intersecting roads Add these calculated values to the admin data The goal is to have road length and vertex statistics for each state/UT in India. However, we will process only an average sized state in the dataset as the rest of the states/UTs will simply be repetitions of the approach above. Note 1: The spatial intersection (first step of our approach) here may not be completely accurate as we are only checking for roads that intersect each state/UT, but we are not trimming/cutting long roads that lie inside a state/UT and extend partially outside of it. Note 2: For simplicity, We have not projected the geographic coordinates (spherical coordinates measured from earth’s center) into planar coordinates (projected geographic coordinates onto a 2D surface) so the intersection algorithm may also not be completely accurate when measuring distances to determine if roads intersect the state/UTs. 5.1 Picking the State for Our Approach We will look at the different areas of the states/UTs in meters squared, and pick a state closest to the average area as our selection criteria. The idea is to select a state with an average area so we have an idea how long it will roughly take to process one state of average size. First, we can compute the areas in meters squared and add it to our administrative areas data admin, then plot it as a bar graph: # Get areas in meters squared and add it to the data admin$area_meters_sq &lt;- st_area(admin) # Sort the data by area admin &lt;- admin[order(-admin$area_meters_sq), ] # Produce a bar plot of the state/UT names and their areas x &lt;- as.numeric(admin$area_meters_sq) y &lt;- admin$NAME_1 par(mar=c(4.5, 6, 0, 1)) # Increase margins to fit plot barplot(x, names.arg = y, horiz = T, las = 2, cex.names = 0.5, # hor. labels border = &quot;white&quot;) # line color of bars We can see from the graph that India has relatively even number of state/UTs of varying sizes from 34854465.8555182 to 341901545477.538. Next, we want to get the state closest to the average size given all states/UTs in India. For reference, this will be the state/UT with an area that has the smallest absolute difference from the average state/UT area: The mean can be calculated as: \\[ \\bar{x} = \\frac{x_1 + x_2 + x_3 \\dots x_n}{n} \\] where \\(\\bar{x}\\) is the average area of all state/UTs, \\(x_1 + x_2 + x_3 \\dots x_n\\) is the sum of the areas for a states 1 to 36, and \\(n\\) is the number of states (36 in this case). x &lt;- admin$area_meters_sq xMean &lt;- mean(x) The absolute differences from the average area for each state/UT are then represented as a set \\(\\{d_1, d_2, d_3 \\dots d_n\\}\\) given by subtracting the state/UT areas \\(\\{x_1, x_2, x_3, \\dots x_n\\}\\) from the average area of all state/UTs \\(\\bar{x}\\): \\[ \\{d_1, d_2, d_3 \\dots d_n\\} = | \\{x_1, x_2, x_3, \\dots x_n\\} - \\bar{x}| \\] d &lt;- abs(x - xMean) We then want the state/UT with the smallest difference from the set (the state/UT with an area closest to the average size of all states/UTs in India), stored in the variable stateUT: \\[ min(\\{d_1, d_2, d_3 \\dots d_n\\}) \\] dMin &lt;- min(d) stateUT &lt;- admin[which(d == dMin),] Let’s inspect the state/UT we picked from our selection criteria: stateUT[, c(&quot;NAME_1&quot;, &quot;area_meters_sq&quot;)] ## Simple feature collection with 1 feature and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 85.82636 ymin: 21.53945 xmax: 89.87755 ymax: 27.22103 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## NAME_1 area_meters_sq geometry ## 36 West Bengal 85229170237 [m^2] MULTIPOLYGON (((88.01861 21... We can see that we selected state/UT West Bengal, with an area of 85229170236.714 meters squared, which is close to the average area of 87564698596.7968 meters squared. 5.2 Extracting Intersecting Roads Now that we have selected our state/UT, lets start the extraction by trying to get all the roads that intersect a single state/UT (since this is the start, we also want to keep track of the processing time with Sys.time): # Track the start time of our extraction process for a single state/UT startTime1 &lt;- Sys.time() # Get intersecting roads for state/UT inStateUT &lt;- st_intersects(roads, stateUT, sparse = F) stateUTRoads &lt;- roads[inStateUT, ] # Time for intersection processing intersectTime &lt;- Sys.time() - startTime1 # Plot the intersecting roads with the state/UT to check plot(st_geometry(stateUT), axes = T, border = &quot;red&quot;) plot(st_geometry(stateUTRoads), add = T) Looking at the plot, we can see that we have extracted the roads that touch or intersect the second state West Bengal, but it does not actually trim or cut the roads when they extend past the administration borders. We can use st_intersection (will trim and only keep geometries that are inside the state/UT) for more accuracy, but the computation time would rise drastically, so we will stick with st_intersects (only checks for TRUE or FALSE comparisons, but does not modify the geometries) for now. 5.3 Calculating Road Lengths and Vertex Statistics Lets move on and extract the min/max/mean/sum road lengths and vertices for West Bengal: # Track the time it takes for calculating road lengths and vertices startTime2 &lt;- Sys.time() # Extract the length stats stateUTRoadsLength &lt;- st_length(stateUTRoads) stateUTLengthStats &lt;- c(min(stateUTRoadsLength, na.rm = T), max(stateUTRoadsLength, na.rm = T), mean(stateUTRoadsLength, na.rm = T), sum(stateUTRoadsLength, na.rm = T)) stateUTLengthStats &lt;- as.numeric(stateUTLengthStats) # Extract the vertices stats stateUTRoadsVertex &lt;- npts(stateUTRoads, by_feature = T) stateUTVertexStats &lt;- c(min(stateUTRoadsVertex, na.rm = T), max(stateUTRoadsVertex, na.rm = T), mean(stateUTRoadsVertex, na.rm = T), sum(stateUTRoadsVertex, na.rm = T)) stateUTVertexStats &lt;- as.numeric(stateUTVertexStats) # Time for calculating lengths and vertices calcTime &lt;- Sys.time() - startTime2 # Combine the stats and name them stateUTStats &lt;- c(stateUTLengthStats, stateUTVertexStats) names(stateUTStats) &lt;- c(&quot;min_length_meters&quot;, &quot;max_length_meters&quot;, &quot;mean_length_meters&quot;, &quot;sum_length_meters&quot;, &quot;min_vertices_meters&quot;, &quot;max_vertices_meters&quot;, &quot;mean_vertices_meters&quot;, &quot;sum_vertices_meters&quot;) print(stateUTStats) ## min_length_meters max_length_meters mean_length_meters ## 2.127547e-01 7.317646e+04 1.177045e+04 ## sum_length_meters min_vertices_meters max_vertices_meters ## 1.053455e+07 2.000000e+00 5.700000e+01 ## mean_vertices_meters sum_vertices_meters ## 9.212291e+00 8.245000e+03 5.4 Adding Statistics to the State/UT Finally, we can add the calculated road lengths and vertex statistics to the state/UT West Bengal by converting it into a dataframe, adding the statistics, and then converting it back into a sf object: # Add the stats to the single state/UT stateUT &lt;- data.frame(stateUT) stateUT[, names(stateUTStats)] &lt;- stateUTStats stateUT &lt;- st_sf(stateUT) # Interactively view the results mapview(stateUT, viewer.suppress = F) Click on the state, and you will now notice that there are extra data on the road length and vertex statistics added to it. 5.5 Reviewing the Processing Times for Extraction Now that we have extracted the road lengths and vertices for the state, we can check how long it took us approximately to process the steps. Remember that we tracked the intersection processing time intersectTime and road length/vertices calculation time calcTime. Lets have a look at these: # Calculate the total processing time totalTime &lt;- intersectTime + calcTime # Display the processing times cat(&quot;Spatial Intersection:&quot;, format(intersectTime, usetz = T), &quot;\\nRoad Length/Vertices Calculation Time:&quot;, format(calcTime, usetz = T), &quot;\\nTotal Time:&quot;, format(totalTime, usetz = T)) ## Spatial Intersection: 10.79003 secs ## Road Length/Vertices Calculation Time: 0.052001 secs ## Total Time: 10.84203 secs We can see that the total time for our extraction approach is 10.84203 secs, which could roughly be more or less 10.84203 secs multiplied by 36 (the number of state/UTs) for an estimate of 390.3131 secs. This could scale to much larger processing times if we were to use more detailed data, or if we were to use smaller levels of administrative boundaries/geometries of interest. However, processing one state/UT will give us a good idea of how long it will take to process all states/UTs. Note: We did not consider the min/max/mean/sum calculations that may factor into the time and the addition of the calculated statistics into the admin dataset, but they generally should not take too much processing time. "],
["ending-off-with-a-few-thoughts.html", "6 Ending Off with a Few Thoughts", " 6 Ending Off with a Few Thoughts So we started with the idea to extract a number of informative aggregate characteristics of roads in India by state/UT, but found that there may be some issues with accuracy (coordinate system and trimming near state/UT boundaries) and computation time (time it took to process one state/UT). Ideally, we should project each state/UT to an appropriate planar coordinate system to achieve more accurate spatial intersection results. There should probably also be a good amount of trimming/cutting involved as roads tend to be partially outside the boundaries of the states/UTs. Although the data was only a few megabytes, the computation time was roughly 10.84203 secs minutes for the single state/UT, estimated to be 390.3131 secs for all state/UTs. This could be problematic as we receive finer boundary or road data, and scale to larger more detailed datasets. Some exploration into optimizing the spatial intersections and trimming/cutting could be a good start to obtaining quicker results in a reasonable amount of time (especially for learning or education). Getting the road lengths and vertices statistics could be useful (as far as I can tell) in providing information on road complexity and development. This could be a potentially good measure for getting a glimpse at the general road design at a state/UT level, while providing some insight into whether or not road design at that level has an effect on important applications such as road traffic safety. Overall, R has proven to be great for trying out ideas, experimenting with new libraries, and providing an easier transition into open source data analysis for those unfamiliar with spatial data handling - particularly when install.packages just works without any hiccups on windows! I am hoping to take this idea a little further and apply it to study traffic crashes in India, and perhaps refine this walkthrough so it becomes a little more beginner friendly. It was a lot of fun to write this and I’m hoping to try out some more ideas when I have some more time! "]
]
